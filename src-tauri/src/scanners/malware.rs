use serde::Serialize;
use std::fs;

#[derive(Debug, Serialize)]
pub struct MalwareResult {
    pub threats_found: Vec<String>,
    pub status: String,
}

const SUSPICIOUS_FILES_MACOS: &[&str] = &[
    "com.genieo.engine.plist",
    "com.searchbar.plist",
    "com.mackeeper.MacKeeper.HLP.plist",
    "com.zeobit.MacKeeper.Helper.plist",
    "com.vsearch.agent.plist",
    "com.adware.analyser.plist",
    "com.pcv.hlpramc.plist",
    "com.spigot.ApplicationManager.plist",
];

const SUSPICIOUS_FILES_WINDOWS: &[&str] = &[
    "mssettings.exe",
    "svchost.exe.exe",
    "scvhost.exe",
    "lsass.exe.exe",
    "syshost.exe",
    "win-mngr.exe",
    "miner.exe",
];

pub fn scan_malware() -> MalwareResult {
    let mut threats = Vec::new();
    
    // --- macOS Scan ---
    #[cfg(target_os = "macos")]
    {
        let home = dirs::home_dir().unwrap_or(std::path::PathBuf::from("/"));
        let scan_paths = [
            home.join("Library/LaunchAgents"),
            std::path::PathBuf::from("/Library/LaunchAgents"),
            std::path::PathBuf::from("/Library/LaunchDaemons"),
        ];
    
        for dir in &scan_paths {
            if let Ok(entries) = fs::read_dir(dir) {
                for entry in entries.flatten() {
                    let path = entry.path();
                    if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                        if SUSPICIOUS_FILES_MACOS.contains(&name) {
                            threats.push(format!("Known Adware/PUP found: {} in {:?}", name, dir));
                        }
                        if name.starts_with('.') {
                             threats.push(format!("Suspicious hidden file in LaunchAgent: {:?}", path));
                        }
                    }
                }
            }
        }
    }

    // --- Windows Scan ---
    #[cfg(target_os = "windows")]
    {
        let home = dirs::home_dir().unwrap_or(std::path::PathBuf::from("C:\\"));
        
        // 1. Scan Startup folder
        let startup_path = home.join("AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup");
        if let Ok(entries) = fs::read_dir(&startup_path) {
            for entry in entries.flatten() {
                let name = entry.file_name().to_string_lossy().to_lowercase();
                if name.ends_with(".exe") || name.ends_with(".bat") || name.ends_with(".vbs") {
                    // Alert on unusual exe names in startup
                    if name.len() < 5 || SUSPICIOUS_FILES_WINDOWS.contains(&name.as_str()) {
                        threats.push(format!("Suspicious startup item: {}", name));
                    }
                }
            }
        }

        // 2. Scan Common Temp locations for double extensions
        let temp_path = home.join("AppData\\Local\\Temp");
        if let Ok(entries) = fs::read_dir(&temp_path) {
            for entry in entries.flatten() {
                let name = entry.file_name().to_string_lossy().to_lowercase();
                if name.contains(".exe.exe") || name.contains(".pdf.exe") || name.contains(".txt.exe") {
                    threats.push(format!("Malicious double-extension found in Temp: {}", name));
                }
            }
        }
    }

    let status = if threats.is_empty() {
        "Your System is safe. No threats found.".to_string()
    } else {
        format!("Found {} potential threats.", threats.len())
    };

    MalwareResult {
        threats_found: threats,
        status,
    }
}
